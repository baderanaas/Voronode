Generate a Cypher query for Neo4j based on this action.

Action: "{{ action }}"
Original User Query: "{{ original_query }}"
{% if context_info %}{{ context_info }}{% endif %}

Neo4j Graph Schema:

Nodes:
- Invoice (id, invoice_number, date, due_date, amount, status)
- LineItem (id, description, cost_code, quantity, unit_price, total)
- Contract (id, contract_id, contractor_id, project_id, value, retention_rate, start_date, end_date, approved_cost_codes, unit_price_schedule)
- Contractor (id, contractor_id, name, license_number, rating)
- Project (id, project_id, name, budget, start_date, end_date, status)
- Budget (id, budget_id, project_id, total_allocated, total_spent, total_remaining)
- BudgetLine (id, cost_code, description, allocated, spent, remaining)

Relationships (EXACT names — do NOT invent others):
- (Contractor)-[:ISSUED]->(Invoice)
- (Invoice)-[:BILLED_AGAINST]->(Contract)
- (Invoice)-[:CONTAINS_ITEM]->(LineItem)
- (LineItem)-[:MAPS_TO]->(BudgetLine)
- (Contractor)-[:HAS_CONTRACT]->(Contract)
- (Contract)-[:FOR_PROJECT]->(Project)
- (Project)-[:HAS_BUDGET]->(Budget)
- (Budget)-[:HAS_LINE]->(BudgetLine)

IMPORTANT:
- Use contract_id property for Contract nodes (e.g. WHERE c.contract_id = 'CONTRACT-010')
- Use invoice_number property for Invoice nodes
- Use contractor_id property for Contractor nodes
- Use project_id property for Project nodes
- Invoices link to Projects ONLY via Contract: (Invoice)-[:BILLED_AGAINST]->(Contract)-[:FOR_PROJECT]->(Project)

Guidelines:
1. Return ONLY the Cypher query, no explanation
2. Use MATCH patterns appropriate for the schema
3. Include WHERE clauses for filtering
4. Use WITH for intermediate aggregations, then RETURN at the end
5. Add LIMIT if querying many records (default: 100)
6. Use proper Cypher syntax (case-sensitive)
7. For amounts, use numeric comparisons (e.g., i.amount > 50000)
8. For dates, use date() function (e.g., i.date > date('2025-01-01'))
9. Use OPTIONAL MATCH for relationships that might not exist

CRITICAL CYPHER SYNTAX RULES (NOT SQL):
- NEVER use GROUP BY - Cypher does NOT support GROUP BY clause
- Aggregation is IMPLICIT: when you use SUM(), COUNT(), etc., Cypher automatically groups by non-aggregated fields
- Never use RETURN followed by WITH (correct order: MATCH ... WITH ... RETURN)
- No HAVING clause - use WHERE after WITH instead

CORRECT Cypher aggregation:
✓ WITH project, SUM(invoice.amount) AS total RETURN project, total
✗ WITH project, SUM(invoice.amount) AS total GROUP BY project -- WRONG (no GROUP BY in Cypher)

Common patterns:
- Find invoices: MATCH (i:Invoice) WHERE i.amount > 50000 RETURN i LIMIT 100
- Find invoices by contractor: MATCH (c:Contractor)-[:ISSUED]->(i:Invoice) WHERE c.contractor_id = 'CONT-001' RETURN i, c
- Find invoices for a contract: MATCH (i:Invoice)-[:BILLED_AGAINST]->(c:Contract) WHERE c.contract_id = 'CONTRACT-010' RETURN i, c
- Find invoices for a project: MATCH (i:Invoice)-[:BILLED_AGAINST]->(ct:Contract)-[:FOR_PROJECT]->(p:Project) WHERE p.project_id = 'PRJ-001' RETURN i, p
- Aggregations (NO GROUP BY): MATCH (c:Contractor)-[:ISSUED]->(i:Invoice) WITH c.name AS contractor, SUM(i.amount) AS total RETURN contractor, total ORDER BY total DESC LIMIT 5
- Budget variance: MATCH (p:Project)-[:HAS_BUDGET]->(b:Budget) MATCH (i:Invoice)-[:BILLED_AGAINST]->(ct:Contract)-[:FOR_PROJECT]->(p) WITH p.name AS project, b.total_allocated AS budget, SUM(i.amount) AS spent RETURN project, budget, spent, (spent - budget) AS variance LIMIT 100
- Sort: ORDER BY i.amount DESC
- Limit: LIMIT 100

Return ONLY a JSON object with the Cypher query in this exact format:
{
    "query": "MATCH (i:Invoice) WHERE i.amount > 50000 RETURN i LIMIT 100"
}
